<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on</title><link>https://pyhrr0.github.io/posts/</link><description>Recent content in Posts on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 10 Mar 2023 13:33:37 +0000</lastBuildDate><atom:link href="https://pyhrr0.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust: generic (smart) pointers using GATs.</title><link>https://pyhrr0.github.io/posts/rust-generic-pointers/</link><pubDate>Fri, 10 Mar 2023 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/rust-generic-pointers/</guid><description>Generic associated types (GATs) allow you to define type, lifetime or const generics on associated types. An example use case can be found below:
use std::ops::Deref; use std::rc::Rc; use std::sync::{Arc, Mutex}; trait SmartPointer { type Pointer&amp;lt;Target&amp;gt;: Deref&amp;lt;Target = Target&amp;gt; + Clone; fn new&amp;lt;T&amp;gt;(value: T) -&amp;gt; Self::Pointer&amp;lt;T&amp;gt;; } struct NonAtomic; impl SmartPointer for NonAtomic { type Pointer&amp;lt;Target&amp;gt; = Rc&amp;lt;Target&amp;gt;; fn new&amp;lt;T&amp;gt;(value: T) -&amp;gt; Rc&amp;lt;T&amp;gt; { Rc::new(value) } } struct Atomic; impl SmartPointer for Atomic { type Pointer&amp;lt;Target&amp;gt; = Arc&amp;lt;Target&amp;gt;; fn new&amp;lt;T&amp;gt;(value: T) -&amp;gt; Arc&amp;lt;T&amp;gt; { Arc::new(value) } } #[derive(Debug)] struct Foo&amp;lt;P: SmartPointer&amp;gt; { value: P::Pointer&amp;lt;Mutex&amp;lt;u32&amp;gt;&amp;gt;, } impl&amp;lt;P: SmartPointer&amp;gt; Clone for Foo&amp;lt;P&amp;gt; { fn clone(&amp;amp;self) -&amp;gt; Self { Self { value: self.</description></item><item><title>Rust: typestate pattern</title><link>https://pyhrr0.github.io/posts/rust-typestate-pattern/</link><pubDate>Sat, 25 Feb 2023 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/rust-typestate-pattern/</guid><description>The type state pattern can be used to prevent consumers of your API from misusing it. It takes advantage of Rust&amp;rsquo;s type system, using generics and zero-sized types.
use std::marker::PhantomData; struct Landed; struct Flying; struct Aeroplane&amp;lt;State = Landed&amp;gt; { state: PhantomData&amp;lt;State&amp;gt;, } impl Aeroplane&amp;lt;Landed&amp;gt; { fn new() -&amp;gt; Self { Self { state: Default::default(), } } fn take_off(self) -&amp;gt; Aeroplane&amp;lt;Flying&amp;gt; { Aeroplane { state: PhantomData::&amp;lt;Flying&amp;gt;, } } } impl Aeroplane&amp;lt;Flying&amp;gt; { fn land(self) -&amp;gt; Aeroplane&amp;lt;Landed&amp;gt; { Aeroplane { state: PhantomData::&amp;lt;Landed&amp;gt;, } } } impl&amp;lt;State&amp;gt; Aeroplane&amp;lt;State&amp;gt; { fn adjust_flaps(&amp;amp;self) { unimplemented!</description></item><item><title>Rust: builder pattern</title><link>https://pyhrr0.github.io/posts/rust-builder-pattern/</link><pubDate>Tue, 07 Feb 2023 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/rust-builder-pattern/</guid><description>The Builder pattern is a creational design pattern that allows for the creation of complex objects step by step, without exposing the internal representation of the object being built. The pattern is especially useful in situations where the object being created has multiple optional parameters, as it allows for easy creation of objects with different combinations of options.
#[derive(Debug)] struct Pizza { dough: String, sauce: String, toppings: Vec&amp;lt;String&amp;gt;, } #[derive(Default)] struct PizzaBuilder { dough: String, sauce: String, toppings: Vec&amp;lt;String&amp;gt;, } impl PizzaBuilder { fn new() -&amp;gt; Self { Self::default() } fn with_dough(mut self, dough: &amp;amp;str) -&amp;gt; Self { self.</description></item><item><title>Rust: monomorphisation</title><link>https://pyhrr0.github.io/posts/rust-monomorphisation/</link><pubDate>Sat, 04 Feb 2023 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/rust-monomorphisation/</guid><description>use std::ops::Add; fn add&amp;lt;T: Add&amp;lt;Output = T&amp;gt;&amp;gt;(a: impl Into&amp;lt;T&amp;gt;, b: impl Into&amp;lt;T&amp;gt;) -&amp;gt; T { a.into() + b.into() } fn main() { add::&amp;lt;i64&amp;gt;(42_i64, 42_i32); add::&amp;lt;i32&amp;gt;(42_i32, 42_i16); add::&amp;lt;i16&amp;gt;(42_i16, 42_i8); add::&amp;lt;i8&amp;gt;(42_i8, 42_i8); add::&amp;lt;f64&amp;gt;(42, 4.2); add::&amp;lt;f64&amp;gt;(4.2, 42); } $ objdump -C -t target/debug/my_binary | grep my_binary::add 0000000000009260 l F .text 00000000000000b0 my_binary::add 0000000000009310 l F .text 00000000000000c4 my_binary::add 0000000000009020 l F .text 00000000000000bb my_binary::add 00000000000093e0 l F .text 00000000000000cb my_binary::add 00000000000090e0 l F .</description></item><item><title>Rust: polymorphism</title><link>https://pyhrr0.github.io/posts/rust-polymorphism/</link><pubDate>Fri, 03 Feb 2023 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/rust-polymorphism/</guid><description>Using Enums enum Animal { Cow, Pig, Rabbit, } impl Animal { fn make_noise(&amp;amp;self) { let noise = match self { Animal::Cow =&amp;gt; &amp;#34;Moo!&amp;#34;, Animal::Pig =&amp;gt; &amp;#34;Oink!&amp;#34;, _ =&amp;gt; &amp;#34;Default noise!&amp;#34;, }; println!(&amp;#34;{noise}&amp;#34;) } } fn main() { let (cow, pig, rabbit) = (Animal::Cow, Animal::Pig, Animal::Rabbit); cow.make_noise(); pig.make_noise(); rabbit.make_noise(); } Using traits trait Animal { fn make_noise(&amp;amp;self) { println!(&amp;#34;Default noise!&amp;#34;) } } struct Cow; impl Animal for Cow { fn make_noise(&amp;amp;self) { println!</description></item><item><title>Rust: ownership model</title><link>https://pyhrr0.github.io/posts/rust-ownership-model/</link><pubDate>Sat, 28 Jan 2023 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/rust-ownership-model/</guid><description>To avoid memory leaks and data race conditions, Rust utilises a unique ownership model, which governs how memory is managed. It&amp;rsquo;s a game-changer when it comes to safe, efficient, and easy-to-reason-about code.
Here&amp;rsquo;s how it works:
Each value in Rust has a variable that&amp;rsquo;s called its owner. Only the owner can decide when the value will be dropped (deallocated from memory). When a value goes out of scope, it is automatically dropped.</description></item><item><title>SOLID in a nutshell</title><link>https://pyhrr0.github.io/posts/solid-in-a-nutshell/</link><pubDate>Fri, 27 Jan 2023 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/solid-in-a-nutshell/</guid><description>SOLID is an acronym for five software design principles that aim to make code more maintainable and flexible. These principles can be applied to any programming language and can help developers write better code that is easier to understand, change, and test.
The five SOLID principles are:
Single Responsibility Principle:
A class should have one and only one reason to change, meaning that it should have a single, well-defined responsibility.</description></item><item><title>K8S security</title><link>https://pyhrr0.github.io/posts/k8s-hardening/</link><pubDate>Fri, 12 Aug 2022 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/k8s-hardening/</guid><description>Host Security Keep your K8S daemons / distro up to date. https://www.flatcar.org/ Ensure RBAC is utilized in a proper manner. ClusterRole ClusterRoleBinding Role RoleBinding https://github.com/alcideio/rbac-tool Ensure serviceaccount secrets don&amp;rsquo;t get mounted automatically. pod.spec.automountServiceAccountToken Run as non-root. podsecuritypolicies.spec.runAsUser podsecuritypolicies.spec.runAsGroup Mount root filesystems as read-only. podsecuritypolicies.spec.readOnlyRootFilesystem Disallow privilege escalations. podsecuritypolicies.spec.allowPrivilegeEscalation Make use of seccomp.</description></item><item><title>Datastructures: Merkle tree</title><link>https://pyhrr0.github.io/posts/merkle-trees/</link><pubDate>Tue, 12 Jul 2022 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/merkle-trees/</guid><description>Summary Merkle trees (aka hash trees) are tree-like datastructures, that separate data validation from the the data itself. These trees consist of the following items:
Leaves (aka outer nodes aka leaf node) Data objects, that are labelled with: hash(associated_data). Branches (aka inner nodes aka inodes aka non-leaf node) Data objects, that are labelled with: hash(concatenate(child_node_hashes)). ┌──────────┐ │ H7 │ Merkle root │ H(H5|H6) │ ┌────────┴──────────┴──────────┐ │ │ │ │ ┌────┴─────┐ ┌─────┴────┐ │ H5 │ │ H6 │ Branches │ H(H1|H2) │ │ H(H3|H4) │ └─┬─────┬──┘ └─┬──────┬─┘ │ │ │ │ ┌─────────┴┐ ┌┴─────────┐ ┌────────┴─┐ ┌─┴────────┐ │ H1 │ │ H2 │ │ H3 │ │ H4 │ Leaves │ H(A1) │ │ H(A2) │ │ H(A3) │ │ H(A4) │ └───┬──────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘ │ │ │ │ A1 A2 A3 A4 Data Benefits They provide an efficient way of proving the integrity and validity of data.</description></item><item><title>Arch Linux with FDE, btrfs and EFI support</title><link>https://pyhrr0.github.io/posts/arch-fde-btrfs-efi/</link><pubDate>Fri, 21 Jan 2022 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/arch-fde-btrfs-efi/</guid><description>Disk preparations Create two partitions (for /boot and /):
# fdisk /dev/sda g - create a new empty GPT partition table n - add a new partition t - change a partition type Create / initialize usable LUKS container (and accompanying volumes):
# cryptsetup luksFormat /dev/sda2 # cryptsetup open /dev/sda2 luks # pvcreate /dev/mapper/luks # vgcreate encrypted /dev/mapper/luks # lvcreate -l 100%FREE encrypted -n rootfs Create filesystems and mount partitions:</description></item><item><title>ELI5: Taproot activation</title><link>https://pyhrr0.github.io/posts/taproot/</link><pubDate>Wed, 08 Dec 2021 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/taproot/</guid><description>The aim of this post is to provide a brief summary, of the implications that come with the adoption of Bitcoin&amp;rsquo;s recent Taproot softfork. Its aim is to optimize Bitcoin&amp;rsquo;s
scalability, privacy, and smart contract functionality.
I got to learn about the nitty gritty details that are involved with the Bitcoin protocol whilst working for Bitonic, a BTCEUR exchange with proper moral values. Do note,
I can&amp;rsquo;t stress enough the importance of the DYOR (Do Your Own Research) idiom.</description></item><item><title>How to nail job interviews</title><link>https://pyhrr0.github.io/posts/interview-cheat-sheet/</link><pubDate>Mon, 29 Nov 2021 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/interview-cheat-sheet/</guid><description>Stage 1: Introduction Requirements:
Have faith in yourself. Remember that all parties involved, are mere human beings. Ensure you know what the client&amp;rsquo;s needs are (as far as possible), and what their occupation is. Things to share:
Your name Family status Place of residence Your hobbies Goal: try to find common ground.
Stage 2: Questionnaire Requirements:
Have a clear image of what drives you / you want to achieve (in general).</description></item></channel></rss>
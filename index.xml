<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://pyhrr0.github.io/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 21 Nov 2021 13:33:37 +0000</lastBuildDate><atom:link href="https://pyhrr0.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust polymorphism</title><link>https://pyhrr0.github.io/posts/rust-polymorphism/</link><pubDate>Fri, 03 Feb 2023 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/rust-polymorphism/</guid><description>Using Enums enum Animal { Cow, Pig, Rabbit, } impl Animal { fn make_noise(&amp;amp;self) { let noise = match self { Animal::Cow =&amp;gt; &amp;#34;Moo!&amp;#34;, Animal::Pig =&amp;gt; &amp;#34;Oink!&amp;#34;, _ =&amp;gt; &amp;#34;Default noise!&amp;#34;, }; println!(&amp;#34;{noise}&amp;#34;) } } fn main() { let (cow, pig, rabbit) = (Animal::Cow, Animal::Pig, Animal::Rabbit); cow.make_noise(); pig.make_noise(); rabbit.make_noise(); } Using traits trait Animal { fn make_noise(&amp;amp;self) { println!(&amp;#34;Default noise!&amp;#34;) } } struct Cow; impl Animal for Cow { fn make_noise(&amp;amp;self) { println!</description></item><item><title>Rust's ownership model</title><link>https://pyhrr0.github.io/posts/rust-ownership-model/</link><pubDate>Sat, 28 Jan 2023 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/rust-ownership-model/</guid><description>To avoid memory leaks and data race conditions, Rust utilises a unique ownership model, which governs how memory is managed. It&amp;rsquo;s a game-changer when it comes to safe, efficient, and easy-to-reason-about code.
Here&amp;rsquo;s how it works:
Each value in Rust has a variable that&amp;rsquo;s called its owner. Only the owner can decide when the value will be dropped (deallocated from memory). When a value goes out of scope, it is automatically dropped.</description></item><item><title>SOLID in a nutshell</title><link>https://pyhrr0.github.io/posts/solid-in-a-nutshell/</link><pubDate>Fri, 27 Jan 2023 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/solid-in-a-nutshell/</guid><description>SOLID is an acronym for five software design principles that aim to make code more maintainable and flexible. These principles can be applied to any programming language and can help developers write better code that is easier to understand, change, and test.
The five SOLID principles are:
Single Responsibility Principle:
A class should have one and only one reason to change, meaning that it should have a single, well-defined responsibility. This helps to reduce the number of changes that need to be made to the code when requirements change.</description></item><item><title>K8S security</title><link>https://pyhrr0.github.io/posts/k8s-hardening/</link><pubDate>Fri, 12 Aug 2022 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/k8s-hardening/</guid><description>Host Security Keep your K8S daemons / distro up to date. https://www.flatcar.org/ Ensure RBAC is utilized in a proper manner. ClusterRole ClusterRoleBinding Role RoleBinding https://github.com/alcideio/rbac-tool Ensure serviceaccount secrets don&amp;rsquo;t get mounted automatically. pod.spec.automountServiceAccountToken Run as non-root. podsecuritypolicies.spec.runAsUser podsecuritypolicies.spec.runAsGroup Mount root filesystems as read-only. podsecuritypolicies.spec.readOnlyRootFilesystem Disallow privilege escalations. podsecuritypolicies.spec.allowPrivilegeEscalation Make use of seccomp. pod.spec.securityContext.seccompProfile Enforce SELinux. podsecuritypolicies.spec.seLinux pod.spec.securityContext.seLinuxOptions Make use of sandboxed pods: https://gvisor.dev/ https://katacontainers.io/ Network Security Limit access to the API server / cluster using a firewall.</description></item><item><title>Datastructures: Merkle tree</title><link>https://pyhrr0.github.io/posts/merkle-trees/</link><pubDate>Tue, 12 Jul 2022 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/merkle-trees/</guid><description>Summary Merkle trees (aka hash trees) are tree-like datastructures, that separate data validation from the the data itself. These trees consist of the following items:
Leaves (aka outer nodes aka leaf node) Data objects, that are labelled with: hash(associated_data). Branches (aka inner nodes aka inodes aka non-leaf node) Data objects, that are labelled with: hash(concatenate(child_node_hashes)). ┌──────────┐ │ H7 │ Merkle root │ H(H5|H6) │ ┌────────┴──────────┴──────────┐ │ │ │ │ ┌────┴─────┐ ┌─────┴────┐ │ H5 │ │ H6 │ Branches │ H(H1|H2) │ │ H(H3|H4) │ └─┬─────┬──┘ └─┬──────┬─┘ │ │ │ │ ┌─────────┴┐ ┌┴─────────┐ ┌────────┴─┐ ┌─┴────────┐ │ H1 │ │ H2 │ │ H3 │ │ H4 │ Leaves │ H(A1) │ │ H(A2) │ │ H(A3) │ │ H(A4) │ └───┬──────┘ └────┬─────┘ └────┬─────┘ └────┬─────┘ │ │ │ │ A1 A2 A3 A4 Data Benefits They provide an efficient way of proving the integrity and validity of data.</description></item><item><title>Arch Linux with FDE, btrfs and EFI support</title><link>https://pyhrr0.github.io/posts/arch-fde-btrfs-efi/</link><pubDate>Fri, 21 Jan 2022 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/arch-fde-btrfs-efi/</guid><description>Disk preparations Create two partitions (for /boot and /):
# fdisk /dev/sda g - create a new empty GPT partition table n - add a new partition t - change a partition type Create / initialize usable LUKS container (and accompanying volumes):
# cryptsetup luksFormat /dev/sda2 # cryptsetup open /dev/sda2 luks_container # pvcreate /dev/mapper/luks_container # vgcreate encrypted /dev/mapper/luks_container # lvcreate -l 100%FREE encrypted -n rootfs Create filesystems and mount partitions:</description></item><item><title/><link>https://pyhrr0.github.io/cv/</link><pubDate>Wed, 08 Dec 2021 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/cv/</guid><description>pyhrr0 SUMMARY A computer scientist with an entrepreneurial mindset who greatly values: privacy, decentralisation and transparency. I have a strong tendency to identify, understand and communicate abstract concepts. I would be thrilled to work on anything that promotes my values. EXPERIENCE VNG, DevOps Engineer 2022-08-01 &amp;mdash; Present Established a development cycle for Common Ground's software components. Debugged issues and created / coordinated appropriate resolutions. Ensured Common Ground's technical goals were met.</description></item><item><title>ELI5: Taproot activation</title><link>https://pyhrr0.github.io/posts/taproot/</link><pubDate>Wed, 08 Dec 2021 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/taproot/</guid><description>The aim of this post is to provide a brief summary, of the implications that come with the adoption of Bitcoin&amp;rsquo;s recent Taproot softfork. Its aim is to optimize Bitcoin&amp;rsquo;s
scalability, privacy, and smart contract functionality.
I got to learn about the nitty gritty details that are involved with the Bitcoin protocol whilst working for Bitonic, a BTCEUR exchange with proper moral values. Do note,
I can&amp;rsquo;t stress enough the importance of the DYOR (Do Your Own Research) idiom.</description></item><item><title>How to nail job interviews</title><link>https://pyhrr0.github.io/posts/interview-cheat-sheet/</link><pubDate>Mon, 29 Nov 2021 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/posts/interview-cheat-sheet/</guid><description>Stage 1: Introduction Requirements:
Have faith in yourself. Remember that all parties involved, are mere human beings. Ensure you know what the client&amp;rsquo;s needs are (as far as possible), and what their occupation is. Things to share:
Your name Family status Place of residence Your hobbies Goal: try to find common ground.
Stage 2: Questionnaire Requirements:
Have a clear image of what drives you / you want to achieve (in general).</description></item><item><title/><link>https://pyhrr0.github.io/contact/</link><pubDate>Sun, 21 Nov 2021 13:33:37 +0000</pubDate><guid>https://pyhrr0.github.io/contact/</guid><description/></item></channel></rss>